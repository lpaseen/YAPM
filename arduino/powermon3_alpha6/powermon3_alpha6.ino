/*
 * Alpha 3, added time
 * Alpha 4, added temperature
 * Alpha 5, started buffering
 * powermon3 alpha1, external adc over spi
 * powermon3 alpha2, major code cleanup
 * powermon3 alpha3, changed to do fixed number of cycles instead of look for zero crossings
 * powermon3 alpha4, Added analog mux
 * powermon3 alpha5, digital filtering, see http://openenergymonitor.org/emon/buildingblocks/digital-filters-for-offset-removal and (end of) http://openenergymonitor.org/emon/node/932
 * powermon3 alpha6, added powerfactor
 *
 * 2013-05-23  Peter Sjoberg <peter.sjoberg@hp.com>
 * 	Code cleanup, added channel selection to lcd
 * 2013-06-12  Peter Sjoberg <peter.sjoberg@hp.com>
 *	Changed format, BUFF2, valsum is now /samples
 * 2013-06-27  Peter Sjoberg <peter.sjoberg@hp.com>
 *	Changed ch_valsum to unsigned long, fixed up voltage and lcd
 * 2013-06-28  Peter Sjoberg <peter.sjoberg@hp.com>
 *	Started power factor version
 * 2013-07-07  Peter Sjoberg <peter.sjoberg@hp.com>
 *	Fixed overflow math to work properly
 *
 * $Id: powermon3_alpha6.ino 1350 2016-03-14 18:43:46Z peters $
 *
 */

//avoid compile error, see http://wiki.gentoo.org/wiki/Arduino
// in /usr/share/arduino-1.0.3/hardware/arduino/cores/arduino/Arduino.h
/*
#ifndef Arduino_h
#define Arduino_h
//start: fix the compatibility issue
#define __AVR_LIBC_DEPRECATED_ENABLE__ 1
//end: fix the compatibility issue
*/
// i2C/TWI lib, for date
#include <Wire.h>
#define DS1307_I2C_ADDRESS 0x68

// LCD Panel
#include <LiquidCrystal.h>
// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

//For DS18S20 temp
#include <OneWire.h>
#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega2560__)
OneWire  ds(22);  // Initiate temp reading
#else
OneWire  ds(17);  // Initiate temp reading, 17=analog3
#endif

//To talk to ADC and io mux
#include <SPI.h>
#define ADCmaxChannels 8 // how many channels the adc has. Also indicates where the mux is connected (always last channel)
#define maxChannels 13 //how many channels that has something connected
#define ADCcs 3 // MCP3208 spi-CS is on pin 3
#define MCPcs 2 // spi io->mux, CS on pin 2
//  MCP23S17 registers, all as seen from bank0
//
#define mcp_address 0b01000000 // SPI Address of MCP23S17
#define IODIRA 0x00 // IO Direction Register Address of Port A
#define IODIRB 0x01 // IO Direction Register Address of Port B
#define IOCON  0x0A // Control register
#define GPIOA  0x12 // Register Address of Port A
#define GPIOB  0x13 // Register Address of Port B
#define OLATA  0x14 // Register Address of Outputlatch A
#define OLATB  0x15 // Register Address of Outputlatch B

// Bits of accuracy for the ADC
#define ADCbits 12
// 
const int ADCmax=pow(2,ADCbits);
const int ADChalf=ADCmax/2;

unsigned int ADCmidpoint=ADCmax/2;

//Values from the probes
unsigned   long ADC_Vref; // Vref of the adc
unsigned   long ADC_step_mV; // milliVolt for each ADC value change
unsigned   int  ch_LOWval[maxChannels];       // Lowest raw value read
unsigned   int  ch_HIGHval[maxChannels];      // Highest raw value read
unsigned   int  ch_midpoint[maxChannels];  // midpoint per channel! Need to figure out why it's needed/changes
unsigned   long ch_samplingtime[maxChannels]; // How many millisec it took to sample
unsigned   long ch_valuesummary[maxChannels]; // the raw value calulated in the loop
         double ch_sumV[maxChannels];	      // calculated voltage rms at ADC pin
         double ch_sumI[maxChannels];         // Final value for this channel, calculated Amps except for readVolt where it's main Voltage

unsigned long samplingtime,timethen,timeend,timenow,csamplingtime,ctimethen,ctimenow; // used to calculate sampling time in ms

//For the digital filter
int last_value[maxChannels];
long shifted_filter[maxChannels];
unsigned long totsamples=0;

byte lastkey=1;
byte dispmode=1;
byte basech=3;
float tempC;
byte CurrentMUX=255; //what channel the mux is currently switched to



unsigned int MAXsamples=2000; // How many samples required to cover 200ms (=12cycles at 50Hz or 10 at 60Hz), generated by sampling


//################################################################
// Store a few values in memory, to be dumped on serial port later
// store the raw value to allow the calibrations to be done outside this program
// #define buffersize 40
#define buffersize 40
typedef struct valrec{
  unsigned long sampledate;  
  unsigned long sampletime;
  byte reported;
  int tempC;
  unsigned int samples;
  unsigned long valuesummary[maxChannels]; // the value calulated in the loop
};

valrec buffvalues[buffersize];
int buffhead=0;
boolean WattLast=false;

//################################################################
String inputString = "";         // a string to hold incoming data
boolean stringComplete = false;

//################################################################

// CT: Voltage depends on current, burden resistor, and turns
//SCT-016
//0.01-120A
//3000:1, current only out
#define CT1_BURDEN_RESISTOR      46.2
#define CT1_TURNS                3000
// CT: Amps it's rated for
#define CT1_MAXAMPS              120
// CT: Volts given at max amps
#define CT1_MAXVOLT              2.5

// SCT-013-030
// 0-30A
// 1800:1
// Burden resistor: 62ohm
// 0-1V out

#define CT2_BURDEN_RESISTOR      62
#define CT2_TURNS                1800
// CT: Amps it's rated for
#define CT2_MAXAMPS              30
// CT: Volts given at max amps
#define CT2_MAXVOLT              1.0

// #define DEBUGTX
// #define DEBUGRX
// #define DEBUGSTACK
// #define DEBUGMUX
// #define DEBUGI

#include <stdarg.h>

void p(char *fmt, ... ){
  char tmp[180]; // resulting string limited to 180 chars
  va_list args;
  va_start (args, fmt );
  vsnprintf(tmp, 180, fmt, args);
  va_end (args);
  Serial.print(tmp);
}
 
//Calibration coeficients
//These need to be set in order to obtain accurate results
//Set the above values first and then calibrate futher using normal calibration method described on how to build it page.
//double ICAL     = 1.046;
//double I_RATIO      = (long double)CT_TURNS / CT_BURDEN_RESISTOR * 5 / 1024 * ICAL;


//################################################################
//################################################################
// Memory related functions
extern int __heap_start, *__brkval; 

//================================================================
// calculate free memory
unsigned int freeRam () {
//  extern int __heap_start, *__brkval; 
  int v; 
  return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval); 
} // freeRam

//================================================================
//Fill the stack so we can see how much is unused later
void fillStack() {
  extern int __bss_end;
//  extern uint8_t* __brkval;
  uint8_t* bgn = (uint8_t*)(__brkval ? __brkval : &__heap_start);
  uint8_t* end = (uint8_t*)&bgn - 10;
  while (bgn < end) *bgn++ = 0X55;
} // fillStack

//================================================================
//check how much stack that never been used (still have fillpattern)
unsigned int stackUnused() {
  uint8_t* bgn = (uint8_t*)(__brkval ? __brkval : &__heap_start);
  uint8_t* end = (uint8_t*)&bgn - 10;
  uint8_t* tmp = bgn;
  while (tmp < end && *tmp == 0X55) tmp++;
  return  tmp - bgn;
} // stackUnused

//################################################################
//################################################################
// Read date and time from RTC

//================================================================
// Convert normal decimal numbers to binary coded decimal
byte decToBcd(byte val)
{
  return ( (val/10*16) + (val%10) );
}
//================================================================
// Convert binary coded decimal to normal decimal numbers
byte bcdToDec(byte val)
{
  return ( (val/16*10) + (val%16) );
}

//================================================================
// 1) Sets the date and time on the ds1307
// 2) Starts the clock
// 3) Sets hour mode to 24 hour clock

// Assumes you're passing in valid numbers

void setDateDs1307(byte second,        // 0-59
byte minute,        // 0-59
byte hour,          // 1-23
byte dayOfWeek,     // 1-7
byte dayOfMonth,    // 1-28/29/30/31
byte month,         // 1-12
byte year)          // 0-99
{
  Wire.beginTransmission(DS1307_I2C_ADDRESS);
  Wire.write(0);
  Wire.write(decToBcd(second));    // 0 to bit 7 starts the clock
  Wire.write(decToBcd(minute));
  Wire.write(decToBcd(hour));     
  Wire.write(decToBcd(dayOfWeek));
  Wire.write(decToBcd(dayOfMonth));
  Wire.write(decToBcd(month));
  Wire.write(decToBcd(year));
  Wire.write(0x10); // sends 0x10 (hex) 00010000 (binary) to control register - turns on square wave
  Wire.endTransmission();
}

//================================================================
// Gets the date and time from the ds1307
void getDateDs1307(byte *second,
byte *minute,
byte *hour,
byte *dayOfWeek,
byte *dayOfMonth,
byte *month,
byte *year)
{
  // Reset the register pointer
  Wire.beginTransmission(DS1307_I2C_ADDRESS);
  Wire.write(0);
  Wire.endTransmission();

  Wire.requestFrom(DS1307_I2C_ADDRESS, 7);

  // A few of these need masks because certain bits are control bits
  *second     = bcdToDec(Wire.read() & 0x7f);
  *minute     = bcdToDec(Wire.read());
  *hour       = bcdToDec(Wire.read() & 0x3f);  // Need to change this if 12 hour am/pm
  *dayOfWeek  = bcdToDec(Wire.read());
  *dayOfMonth = bcdToDec(Wire.read());
  *month      = bcdToDec(Wire.read());
  *year       = bcdToDec(Wire.read());
}

//################################################################
//################################################################
// Read the keys on the lcd panel

//================================================================
//Read key from lcd panel
byte readKey(){
  byte key=0;
  unsigned int x;

  x = analogRead (0); // the lcd panel use analog0 for key

  if (x < 100) {
    key=1; // Right
  }
  else if (x < 200) {
    key=2; // Up
  }
  else if (x < 400){
    key=3; //Down
  }
  else if (x < 600){
    key=4; //Left
  }
  else if (x < 800){
    key=5; //Select
  } // else it's no key pressed and 0 is returned
  return key;
} // readKey

//################################################################
//################################################################
// Read ADC

unsigned int adcRead(byte channel){
  int hibit,ret,ret2;
  byte _muxch;
  
  uint8_t tx[] = {
    //  00000sgc   ccxxdddd   DDDDDDDD'
    0b00000110,0b00000000,0b00000000,
  };
  uint8_t rx[] = {
    //  00000sgc   ccx0dddd   DDDDDDDD'
    0,0,0
  };

#ifdef DEBUGTX
  static byte prev_channel;
  static uint8_t prev_tx[2];
#endif

  ret=channel; // save incoming channel for possible printout later

  if (channel >= ADCmaxChannels-1){ //ADCmaxChannels:1 based, channel:0 based
    _muxch=channel-ADCmaxChannels+1;
    channel=ADCmaxChannels-1; // the channel the mux comes in on
    if (CurrentMUX!=_muxch){ //need to move the mux
#ifdef DEBUGMUX
      Serial.print("Changing mux, channel= ");
      Serial.print(ret);
      Serial.print(", MUX: ");
      Serial.print(_muxch);
      Serial.print(", New channel: ");
      Serial.print(channel);
      Serial.println();
#endif
      digitalWrite(MCPcs,LOW);
      SPI.transfer(mcp_address);   // Target address 000 and set the R/W bit to Write(0)
      SPI.transfer(GPIOA);        // We want to access Port A
      SPI.transfer(_muxch);          // Select MUX channel, 0x00-0x0F, 0x10 would disable the mux. 
      CurrentMUX=_muxch;
      digitalWrite(MCPcs,HIGH);
      delay(3); // give it time to settle, dunno how long is needed but spec state worst case is 500ns(gpio)+450ns(MUX) so 3ms should be more then enough.
    }
  }

  hibit=(channel&4)>>2;
  //  channel=channel&3;
  tx[0]+=hibit;
  tx[1]+=(channel&3)<<6;
  tx[2]=0;
  
#ifdef DEBUGTX
  if (prev_channel!=ret || prev_tx[0] != tx[0] || prev_tx[1] != tx[1]){
    prev_channel=ret;
    prev_tx[0]=tx[0];
    prev_tx[1]=tx[1];
    p("TX Channel #%2d =>ADC:%2d,MUX:%2d, tx0:1 %02x:%02x\n",ret,channel,CurrentMUX,tx[0],tx[1]);
    /*
    Serial.print("TX Channel # ");
    Serial.print(ret,DEC);
    Serial.print(",");
    Serial.print(tx[0],HEX);
    Serial.print(" ");
    Serial.print(tx[1],HEX);
    Serial.print(" ");
    Serial.println(tx[2],HEX);
    */
  }
#endif
  // take the SS pin low to select the chip:
  digitalWrite(ADCcs,LOW);
  rx[0]=SPI.transfer(tx[0]);
  rx[1]=SPI.transfer(tx[1]);
  rx[2]=SPI.transfer(tx[2]);
  digitalWrite(ADCcs,HIGH);
  
#ifdef DEBUGRX
  Serial.print("RX Channel # ");
  Serial.print(channel,DEC);
  Serial.print(",");
  if (rx[0]<16) Serial.print("0");
  Serial.print(rx[0],HEX);
  Serial.print(" ");
  if (rx[1]<16) Serial.print("0");
  Serial.print(rx[1],HEX);
  Serial.print(" ");
  if (rx[2]<16) Serial.print("0");
  Serial.print(rx[2],HEX);
  Serial.print(" = ");
  Serial.println(((rx[1] & 0x0f)<<8)+rx[2],DEC);
  //    Serial.println();
#endif

  return ((rx[1] & 0x0f)<<8)+rx[2];
} // adcRead

//#define DEBUGVOLT

//################################################################
double readVolt(byte channel,double RATIO){
  unsigned int _sample;
  unsigned int _samples;
  unsigned int _value;
  unsigned int _MinVal;
  unsigned int _MaxVal;
  
  // http://openenergymonitor.org/emon/buildingblocks/measuring-voltage-with-an-acac-power-adapter
  //
  //  adapter output voltage = mains voltage x transformer ratio
  //  input pin voltage = adapter output voltage / 11
  //      RATIO=input pin voltage
  //  counts = (input pin voltage / 3.3) x 1024
  //      (sample/Vref)*ADCmax
  //  Vmains = count x a constant
  //
  //    In software, in order to convert the count back to a meaningful voltage, it has to be multiplied by a calibration constant.
  //
  // peak-voltage-output = R1 / (R1 + R2) x peak-voltage-input = 10k / (10k + 100k) x 12.7V = 1.15V
  // 

  //find the peak value (we just need max voltage, no need for fancy rms
  
  _MinVal=ADCmax-1;
  _MaxVal=1;
  // follow it to min value
  for (_sample=0;_sample<MAXsamples;_sample++){
    _value=adcRead(channel);
    _MinVal=min(_MinVal,_value);
    _MaxVal=max(_MaxVal,_value);
  }

  // Since the AC voltage is unloaded it's a nice sinus wave to be used as base for some other math
  ADCmidpoint=((_MaxVal-_MinVal)/2)+_MinVal;
  ch_LOWval[channel]=_MinVal;
  ch_HIGHval[channel]=_MaxVal;
  ch_midpoint[channel]=((_MaxVal-_MinVal)/2)+_MinVal;

#ifdef DEBUGVOLT
  Serial.print("ReadVolt; samples, min/max/mid: ");
  Serial.print(_sample);
  Serial.print(",");
  Serial.print(_MinVal);
  Serial.print("/");
  Serial.print(_MaxVal);
  Serial.print("/");
  Serial.println(ADCmidpoint);
#endif
  ch_sumV[channel]=max(_MaxVal-ADCmidpoint,0)*ADC_step_mV;  // mV measured
  ch_sumI[channel]=max(_MaxVal-ADCmidpoint,0)*ADC_step_mV/RATIO; // Main voltage (110-120V AC)
  ch_valuesummary[channel]=_MaxVal-ADCmidpoint; // raw max value

  return ch_sumI[channel];
} //readVolt


//################################################################
double readrmsI(byte channel,double CT_RATIO){
  unsigned int sample;
  unsigned int _sample;
  int _value,_last_value;
  unsigned int _MinVal;
  unsigned int _MaxVal;
  long _shiftedFCL;
  long _filtered_value;
  long _shifted_filter;
  unsigned long _sum,_sumPrev;
  unsigned int _overflow;

  // current constant = (100 / 0.050) / 18 = 111.11
  // a constant = current constant x (3.3 / 1024)
  // Isupply = count x a constant
  // 
  // secondary current = primary current / transformer ratio
  // input pin voltage = secondary current x burden resistance
  // counts = (input pin voltage / 3.3) x 1024

  _MinVal=ADCmax-1;
  _MaxVal=1;
  _sum=0;
  _sumPrev=_sum;
  _overflow=0;

  // Make sure midpoint is set
  if ( ch_midpoint[channel] == 0 ){ch_midpoint[channel]=ADChalf;}
  
  //Look for crossing, wait until value becomes lower then midpint
  //Done in a limited loop to not wait forever
  for (_sample=0;_sample<MAXsamples;_sample++){
    if ( adcRead(channel) < ch_midpoint[channel] ){break;}
  }

  //Look for next crossing (in case it was already below), wait until value becomes higher then midpint
  for (_sample=0;_sample<MAXsamples;_sample++){
    if ( adcRead(channel) > ch_midpoint[channel] ){break;}
  }
  //Time to start the real measuring
  _value = adcRead(channel);
  _shifted_filter=shifted_filter[channel];
  ctimethen =  millis(); // Start timer
  for (_sample=0;_sample<MAXsamples;_sample++){
    _last_value = _value;
    _value=adcRead(channel);
    _MinVal=min(_MinVal,_value);
    _MaxVal=max(_MaxVal,_value);

    _shiftedFCL = _shifted_filter + (long)((_value-_last_value)<<8);
    _shifted_filter = _shiftedFCL - (_shiftedFCL>>8);
    _filtered_value = (_shifted_filter+128)>>8;
    _sum+=_filtered_value*_filtered_value;
    if (_sum < _sumPrev){_overflow++;}
#ifdef DEBUGI
    //    if (_sum>750000000){_overflow++;_sum=0;}; //DEBUGing overflow
    //      if (_sum>1069310616){_overflow++;_sum=0;}; //DEBUGing overflow
    //      if (_sum>2069310616){_overflow++;_sum=0;}; //DEBUGing overflow
#endif
    _sumPrev=_sum;
  }
  ctimenow =  millis(); // stop timer, hope it's close to 200ms
  shifted_filter[channel]=_shifted_filter;

  ch_LOWval[channel]=_MinVal;
  ch_HIGHval[channel]=_MaxVal;
  ch_midpoint[channel]=((_MaxVal-_MinVal)/2)+_MinVal;

  //  ch_valuesummary[channel]=((long long)4294967295+(long long)1)*(long long)_overflow+(long long)_sum/(long long)MAXsamples; //THIS DOES NOT WORK!
  ch_valuesummary[channel]=_sum/MAXsamples+_overflow*4294967295/MAXsamples; //almost Raw ADC
#ifdef DEBUGI
  if (_overflow>0 && ch_valuesummary[channel]< 894598)  Serial.println("ERROR3, Bad math, overflow >0 ch_valsumm < 894598");

  p("Channel %2d, _overflow:%d _sum: %-10lu, samples %d, ch_valuesummary: %6lu, sqrt(ch_val):%6u, filtered: %8ld, lastVal:%6d \n",
    channel,_overflow,_sum,MAXsamples,ch_valuesummary[channel],int(sqrt(ch_valuesummary[channel])),_filtered_value,_value);

#endif

//  ch_sumV[channel]=ch_valuesummary[channel]*(double)ADC_step_mV/1000; // convert to milliV rms
    ch_sumV[channel]=sqrt(ch_valuesummary[channel])*(double)ADC_step_mV/1000; // convert to milliV rms
  ch_sumI[channel]=ch_sumV[channel]/(double)CT_RATIO/(double)1000; // convert milliV rms to AMP
  return ch_sumI[channel];
} // readrmsI

//################################################################
double readPF(byte channelV,byte channelI,double PF_CAL){
  unsigned int sample;
  unsigned int _sample;
  int _valueV,_last_valueV,_valueI,_last_valueI;
  int _phaseShiftedV,_instP;
  long _shiftedFCLV,_filtered_valueV,_shifted_filterV;
  long _shiftedFCLI,_filtered_valueI,_shifted_filterI;
  unsigned long _sumV,_sumI,_sumP;


  _sumV=0;
  _sumI=0;

  // Make sure midpoint is set
  if ( ch_midpoint[channelV] == 0 ){ch_midpoint[channelV]=ADChalf;}
  if ( ch_midpoint[channelI] == 0 ){ch_midpoint[channelI]=ADChalf;}
  
  //Look for crossing, wait until value becomes lower then midpint
  //Done in a limited loop to not wait forever
  //Done on voltage channel since that is unloaded and a nicer sinus wave
  for (_sample=0;_sample<MAXsamples;_sample++){
    if ( adcRead(channelV) < ch_midpoint[channelV] ){break;}
  }

  //Look for next crossing (in case it was already below), wait until value becomes higher then midpint
  for (_sample=0;_sample<MAXsamples;_sample++){
    if ( adcRead(channelV) > ch_midpoint[channelV] ){break;}
  }

  //Time to start the real measuring
  _valueV = adcRead(channelV);
  _valueI = adcRead(channelI);
  _shifted_filterV=shifted_filter[channelV];
  _shifted_filterI=shifted_filter[channelI];
  ctimethen =  millis(); // Start timer
  for (_sample=0;_sample<MAXsamples;_sample++){
    _last_valueV = _valueV;
    _last_valueI = _valueI;
    _valueV=adcRead(channelV);
    _valueI=adcRead(channelI);

    _shiftedFCLV = _shifted_filterV + (long)((_valueV-_last_valueV)<<8);
    _shiftedFCLI = _shifted_filterI + (long)((_valueI-_last_valueI)<<8);
    _shifted_filterV = _shiftedFCLV - (_shiftedFCLV>>8);
    _shifted_filterI = _shiftedFCLI - (_shiftedFCLI>>8);
    _filtered_valueV = (_shifted_filterV+128)>>8;
    _filtered_valueI = (_shifted_filterI+128)>>8;
    _sumV+=_filtered_valueV*_filtered_valueV;
    _sumI+=_filtered_valueI*_filtered_valueI;

    _phaseShiftedV=_filtered_valueV+PF_CAL*(_valueV-_last_valueV);
    _instP = _phaseShiftedV * _filtered_valueI;
    _sumP+=_instP;

  }
  ctimenow =  millis(); // stop timer, hope it's close to 200ms
  shifted_filter[channelV]=_shifted_filterV;
  shifted_filter[channelI]=_shifted_filterI;

  //  ch_valuesummary[channelV]=(double)_sum/MAXsamples; //Raw ADC

#ifdef DEBUGPF

  p("ChannelV %2d,filtered: %6ld, _sum: %-10ld, ch_valuesummary: %6u, _sum/MAXsamples: %6u\n",
    channelV,_filtered_value,_sum,ch_valuesummary[channelV],int(float(_sum/MAXsamples)));
  p(" sqrt(chval):%6u, sqrt2:%6u, _shifted_filter: %6ld, lastVal:%6d \n",
    int(sqrt(ch_valuesummary[channelV])),int(sqrt(float(_sum/MAXsamples))),
    _shifted_filter,_value);

#endif

//rms sqrt(($_sum*$ADC_step_mV*$ADC_step_mV)/$MAXsamples)/1000"
//  ch_sumV[channelV]=abs((double)_filtered_value*(double)ADC_step_mV/1000); // convert to milliV rms
  ch_sumV[channelV]=sqrt((double)_sumV/MAXsamples)*(double)ADC_step_mV/1000; // convert to milliV rms
  ch_sumI[channelV]=ch_sumV[channelV]/(double)PF_CAL/(double)1000; // convert milliV rms to AMP
  return ch_sumI[channelV];
} // readPF
//################################################################
//################################################################
// read temp sensor

//================================================================
// Read temp from the first found sensor (should only be one)
float GetTempC(){
  byte i;
  byte data[12];
  byte addr[8];
  byte present = 0;
  byte type_s;
  
  ds.search(addr);
  if (OneWire::crc8(addr, 7) != addr[7]) {
    Serial.println("CRC is not valid!");
    return -1;
  }
  // the first ROM byte indicates which chip
  switch (addr[0]) {
    case 0x10:
      type_s = 1;
      break;
    case 0x28:
      type_s = 0;
      break;
    case 0x22:
      type_s = 0;
      break;
    default:
      Serial.println("Device is not a DS18x20 family device.");
      return -1;
  }
  ds.reset();
  ds.select(addr);
  ds.write(0x44,1);         // start conversion, with parasite power on at the end
  // this is from the RTC=no parasite power
  // Other setups should check power type during setup()
  // delay(1000);
  present = ds.reset();
  ds.select(addr);    
  ds.write(0xBE);         // Read Scratchpad
  for ( i = 0; i < 9; i++) {           // we need 9 bytes
    data[i] = ds.read();
  }
  // convert the data to actual temperature

  //  unsigned int raw = (data[1] << 8) | data[0];
  int raw = (data[1] << 8) | data[0];
  if (type_s) {
    raw = raw << 3; // 9 bit resolution default
    if (data[7] == 0x10) {
      // count remain gives full 12 bit resolution
      raw = (raw & 0xFFF0) + 12 - data[6];
    }
    } else {
    unsigned char t_mask[4] = {0x7, 0x3, 0x1, 0x0};
    byte cfg = (data[4] & 0x60) >> 5;
    raw &= ~t_mask[cfg];
    }
  tempC = (float)raw / 16.0;
} // GetTempC


//################################################################
//################################################################
// Report the values

//================================================================
// Dump one buffered value to the serial channel
void printValue(int i){
  byte channel;
  Serial.print("BUFF2,");  
  Serial.print(i,DEC);  
  Serial.print(",");
  Serial.print(buffvalues[i].sampledate);  
  Serial.print(",");  
  Serial.print(buffvalues[i].sampletime);  
  Serial.print(",");  
  Serial.print(buffvalues[i].tempC);
  Serial.print(",");  
  Serial.print(buffvalues[i].samples);
  Serial.print(",");  
  Serial.print(ADC_step_mV);
  Serial.print(",");  
  Serial.print(buffvalues[i].reported);
  for (channel=0;channel<maxChannels;channel++){
    Serial.print(",");  
    Serial.print(buffvalues[i].valuesummary[channel]);
  }
  Serial.println();
//  Serial.println();
} // printValue

//================================================================
// Dump all the buffered values to the serial channel
void dumpBuff(boolean all,boolean mark){
  byte channel;
  boolean header=false;
  
  for (buffhead=0;buffhead<buffersize;buffhead++){
    if (all || buffvalues[buffhead].reported==0) {
      if (buffvalues[buffhead].sampletime==0) continue; // skip empty slots
      if (!header){
	Serial.print("#Free ram: ");
	Serial.print(freeRam());
	Serial.print(", stack unused ");
	Serial.println(stackUnused());
	Serial.println("#BEGIN dump buffer; FORMATVER,entry#,date,time,tempC*10,samples,ADC_step_mV,reported,valsum{channels...}");
	//        Serial.println("#BEGIN");
        header=true;
      }
      printValue(buffhead);
      if (mark) buffvalues[buffhead].reported++;
    }
  }
  if (header) Serial.println("#END dump buffer");
} // dumpBuff

//################################################################
//################################################################
// Handle user input

//================================================================
void CheckKeys(){
  byte key;
  
  key=readKey();
  if (key != 0 ) {  lcd.setCursor(15,1);lcd.print(key);}
  if ( key > 0 && key != lastkey){
    if ( key == 1 ) { // right
      dispmode++;
      if (dispmode > 5) dispmode=1;
    } else if (key == 2) { // up
      basech++;
      if (basech > maxChannels-2) basech=0;
    } else if (key == 3) { // down
      if (basech == 0 ) {
	basech=maxChannels-2;
      } else {
	basech--;
      }
    } else if (key == 4) { // left
      dispmode--;
      if ( dispmode<1) dispmode=5;
    }
    lastkey=key;
    lcd.setCursor(15,0);
    lcd.print(dispmode);
  } else if ( key == 0) { // key was released, get ready for next key
    lastkey=key;
  }
} // CheckKeys

//================================================================
/*
  SerialEvent occurs whenever a new data comes in the
 hardware serial RX.  This routine is run between each
 time loop() runs, so using delay inside loop can delay
 response.  Multiple bytes of data may be available.
 */
void serialEvent() {
  while (Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read(); 
    // add it to the inputString:
    inputString += inChar;
    // if the incoming character is a newline, set a flag
    // so the main loop can do something about it:
    if (inChar == '\n' || inChar == '\\' || inputString.length() >= 20){ // Buffer full, work on it
        stringComplete = true; 
        break;
    }
  }
}

//================================================================
//Check if any command entered on serial channel
void CheckSerial(){
  byte second, minute, hour, dayOfWeek, dayOfMonth, month, year;
  char tmp_str[3];

  serialEvent();
  if (stringComplete){
    Serial.print("# string complete: ");
    inputString.toUpperCase();
    Serial.println(inputString);
    //    if (inputString.startsWith("T")) { //Set time
    if (inputString.charAt(0)=='T') { //Set time
      Serial.print("Current time is    : 20");
      getDateDs1307(&second, &minute, &hour, &dayOfWeek, &dayOfMonth, &month, &year);
      Serial.print(year, DEC);
      Serial.print("-");
      if (month<10){Serial.print("0");}
      Serial.print(month, DEC);
      Serial.print("-");
      if (dayOfMonth<10){Serial.print("0");}
      Serial.print(dayOfMonth, DEC);
      Serial.print(" ");
      if (hour <10){Serial.print("0"); }
      Serial.print(hour, DEC);// convert the byte variable to a decimal number when being displayed
      Serial.print(":");
      if (minute<10){Serial.print("0");}
      Serial.print(minute, DEC);
      Serial.print(":");
      if (second<10){Serial.print("0");}
      Serial.print(second, DEC);
      Serial.print(" weekday:");
      Serial.println(dayOfWeek, DEC);
      
      //
      Serial.print("Setting the time to: 20");
      // T1306010248136\
      inputString.substring( 1, 3).toCharArray(tmp_str, sizeof(tmp_str));year=atoi(tmp_str);
      inputString.substring( 3, 5).toCharArray(tmp_str, sizeof(tmp_str));month=atoi(tmp_str);
      inputString.substring( 5, 7).toCharArray(tmp_str, sizeof(tmp_str));dayOfMonth=atoi(tmp_str);
      inputString.substring( 7, 9).toCharArray(tmp_str, sizeof(tmp_str));hour=atoi(tmp_str);
      inputString.substring( 9,11).toCharArray(tmp_str, sizeof(tmp_str));minute=atoi(tmp_str);
      inputString.substring(11,13).toCharArray(tmp_str, sizeof(tmp_str));second=atoi(tmp_str);
      inputString.substring(13,14).toCharArray(tmp_str, sizeof(tmp_str));dayOfWeek=atoi(tmp_str);
      Serial.print(year, DEC);
      Serial.print("-");
      if (month<10){Serial.print("0");}
      Serial.print(month, DEC);
      Serial.print("-");
      if (dayOfMonth<10){Serial.print("0");}
      Serial.print(dayOfMonth, DEC);
      Serial.print(" ");
      if (hour <10){Serial.print("0"); }
      Serial.print(hour, DEC);// convert the byte variable to a decimal number when being displayed
      Serial.print(":");
      if (minute<10){Serial.print("0");}
      Serial.print(minute, DEC);
      Serial.print(":");
      if (second<10){Serial.print("0");}
      Serial.print(second, DEC);
      Serial.print(" weekday:");
      Serial.println(dayOfWeek, DEC);
      setDateDs1307(second, minute, hour, dayOfWeek, dayOfMonth, month, year);

      //
      Serial.print("New time is        : 20");
      getDateDs1307(&second, &minute, &hour, &dayOfWeek, &dayOfMonth, &month, &year);
      Serial.print(year, DEC);
      Serial.print("-");
      if (month<10){Serial.print("0");}
      Serial.print(month, DEC);
      Serial.print("-");
      if (dayOfMonth<10){Serial.print("0");}
      Serial.print(dayOfMonth, DEC);
      Serial.print(" ");
      if (hour <10){Serial.print("0"); }
      Serial.print(hour, DEC);// convert the byte variable to a decimal number when being displayed
      Serial.print(":");
      if (minute<10){Serial.print("0");}
      Serial.print(minute, DEC);
      Serial.print(":");
      if (second<10){Serial.print("0");}
      Serial.print(second, DEC);
      Serial.print(" weekday:");
      Serial.println(dayOfWeek, DEC);

    } else if (inputString.charAt(0)=='D') { // dump any new data and mark it viewed
      dumpBuff(false,true);
    } else if (inputString.charAt(0)=='A') { // dump all data and mark it viewed
      dumpBuff(true,true);
    } else if (inputString.charAt(0)=='S') { // show all data but do NOT mark it viewed
      dumpBuff(true,false);
    }
    // clear the string:
    inputString = "";
    stringComplete = false;    
  }
} // CheckSerial

//################################################################################################################################
//################################################################################################################################
//################################################################################################################################
//################################################################################################################################
void setup()
{
  byte second, minute, hour, dayOfWeek, dayOfMonth, month, year;
  byte channel,i;
  unsigned long result;

  // i2c, date
  Wire.begin();

  // Change these values to what you want to set your clock to.
  // You probably only want to set your clock once and then remove
  // the setDateDs1307 call.
  year = 13;
  month = 6;
  dayOfMonth = 28;
  hour = 3;
  minute = 21;
  second = 40;
  dayOfWeek = 3;
  //  setDateDs1307(second, minute, hour, dayOfWeek, dayOfMonth, month, year);

  //to track memory usage
  fillStack();

  inputString.reserve(21);

  // set the slaveSelectPin as an output:
  pinMode (ADCcs, OUTPUT);
  digitalWrite(ADCcs,HIGH);
  pinMode (MCPcs, OUTPUT);
  digitalWrite(MCPcs,HIGH);

  // initialize SPI:
  SPI.setBitOrder(MSBFIRST);
  SPI.setDataMode(SPI_MODE0);
  // SPI.setClockDivider(SPI_CLOCK_DIV16); // 16MHZ div by 2,4,..,128
  //  SPI.setClockDivider(SPI_CLOCK_DIV4); // 16MHZ div by 2,4,..,128
  // spec for mcp3208 say max spi clock is 2MHz or 16/8
  SPI.setClockDivider(SPI_CLOCK_DIV8); // 16MHZ div by 2,4,..,128
  SPI.begin();


  //Setup the control register
  digitalWrite(MCPcs,LOW);
  SPI.transfer(mcp_address);   // MUX address, write
  SPI.transfer(IOCON);         // Writing to IOCON
  /*
   Reg IOCON = [BANK][MIRROR][SEQOP][DISSLW][HAEN][ODR][INTPOL][-Unused]
     Bit 7 BANK: Controls how the registers are addressed
             1 = The registers associated With each Port are separated into different banks
	     0 = The registers are in the same bank (addresses are sequential)
      Bit 6 MIRROR: INT Pins Mirror Bit
             1 = The INT pins are internally connected
             0 = The INT pins are Not connected. INTA is associated With PortA And INTB is associated With PortB
      Bit 5 SEQOP: Sequential Operation mode Bit.
      	     1 = Sequential operation disabled, address pointer does Not increment.
	     0 = Sequential operation Enabled, address pointer increments.
      Bit 4 DISSLW: Slew Rate control Bit For SDA Output.
             1 = Slew rate disabled.
             0 = Slew rate Enabled.
      Bit 3 HAEN: Hardware Address Enable Bit (MCP23S17 only).
             Address pins are always Enabled on MCP23017.
             1 = Enables the MCP23S17 address pins.
             0 = Disables the MCP23S17 address pins.
      Bit 2 ODR: This Bit configures the INT pin As an open-drain Output.
             1 = Open-drain Output (overrides the INTPOL Bit).
	     0 = Active driver Output (INTPOL Bit sets the polarity).
      Bit 1 INTPOL: This Bit sets the polarity of the INT Output pin.
             1 = Active-High.
             0 = Active-Low.
      Bit 0 Unimplemented: Read As ‘0’.

  */
    //  SPI.transfer(0b00011000)   // Init value for IOCON
  SPI.transfer(0b00110100);   // Init value for IOCON, bank(0)+INTmirror(no)+SQEOP(no addr inc)+DISSLW(Slew rate disabled)+HAEN(disable hw addr)+ODR(INT open)+INTPOL(act-low)+0(N/A)
  digitalWrite(MCPcs,HIGH);

  //Define output
  digitalWrite(MCPcs,LOW);
  SPI.transfer(mcp_address);   // Target address 000 and set the R/W bit to Write(0)
  SPI.transfer(IODIRA);         // We want to access the IODIRA register
  SPI.transfer(0b00000000);   // Set to all outputs
  digitalWrite(MCPcs,HIGH);

  /*
// Write to the Latch of PORTA
  digitalWrite(MCPcs,LOW);
  SPI.transfer(mcp_address);   // Target address 000 and set the R/W bit to Write(0)
  SPI.transfer(OLATA);         // We want to access the OLATA register
  SPI.transfer(0b11111111);    // Enable all outputs logic high
  digitalWrite(MCPcs,HIGH);
*/

// Set a initial value for the MUX
  digitalWrite(MCPcs,LOW);
  SPI.transfer(mcp_address);   // Target address 000 and set the R/W bit to Write(0)
  SPI.transfer(GPIOA);         // We want to access Port A
  SPI.transfer(0b00000000);    // Set all pins low=mux channel 0
  digitalWrite(MCPcs,HIGH);
  CurrentMUX=0;

  //Setup ADC constants
  ADC_Vref=5000; //external prec vref
  ADC_step_mV=(ADC_Vref*1000)/ADCmax; // ADC_step_mV = milliVolt*1000 per ADC step

  Serial.begin(38400);

  // set up the LCD's number of columns and rows:
  lcd.begin(16, 2);
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("  Initializing...");
  Serial.println("  Initializing...");
  // prime all channels plus calculate midpoint for all channels
  //  for (i=0;i<5;i++){
    readVolt(0,9.57);
    for (channel=1;channel<maxChannels;channel++){
      readrmsI(channel,2.5/120);
    }
    //    delay(222);
    //  }

  for (channel=1;channel<maxChannels;channel++){
    last_value[channel]= ADChalf;
    shifted_filter[channel]=-10000;
  }

  lcd.clear();

//  Serial.begin(9600);
  Serial.print("Buffer size: ");
  Serial.print(buffersize);
  Serial.print(", sizeof(buffvalues[0]): ");
  Serial.print(sizeof(buffvalues[0]));
  Serial.print(", freeRam: ");
  Serial.print(freeRam());
  Serial.print(", stackUnused: ");
  Serial.println(stackUnused());
  

} // setup

// ############################################################################
// ############################################################################
void loop()
{

  byte second, minute, hour, dayOfWeek, dayOfMonth, month, year;

  unsigned long sampledate,sampletime; // date & time the sample was done
  //  unsigned long samplingtime,timethen,timeend,timenow,csamplingtime,ctimethen,ctimenow; // used to calculate sampling time in ms
  byte channel;
  //  byte lineVoltage=120;
  unsigned int i;
  float lineVoltage;
  byte prevkey;
  unsigned int waitloop,waitdelay;
  float TotWatt;

  int _value,_last_value;

  unsigned int _MinVal;
  unsigned int _MaxVal;
  long _shiftedFCL;
  long _filtered_value;
  long _shifted_filter;
  long _sum;


  /* DEBUG
  Serial.println("");
  Serial.write("ADC :");
  for (i=0;i<maxChannels;i++){
    Serial.print(adcRead(i));
    if (i != maxChannels-1) Serial.write(",");
  }
  Serial.println("");
  */

  //  Serial.print("Calibrating");

  // calibrate, Calculate how many samples that can be done in 200ms
  MAXsamples=0;
  timethen =  millis();
  //  timeend=timethen+211; // stop after 200ms+some overhead
  //  timeend=timethen+198; // stop after 200ms-some overhead to get readrmsI to be done over 200ms
  timeend=timethen+174; // stop after 200ms-some the "timenow = millis()" overhead to get readrmsI to be done over 200ms
  timenow = millis();
  while (timenow<timeend){
    MAXsamples++;
#ifdef FLOAT
    lastSampleI = sampleI;
    sampleI = analogRead(channel);
    filteredI = 0.996*(lastFilteredI+sampleI-lastSampleI);
    sqI = filteredI * filteredI;
    sumI += sqI;
#else
    //Need to have the same code as in readrmsI here
    _last_value = _value;
    _value=adcRead(3);
    _MinVal=min(_MinVal,_value);
    _MaxVal=max(_MaxVal,_value);

    _shiftedFCL = _shifted_filter + (long)((_value-_last_value)<<8);
    _shifted_filter = _shiftedFCL - (_shiftedFCL>>8);
    _filtered_value = (_shifted_filter+128)>>8;
    _sum+=_filtered_value*_filtered_value;
#endif
    timenow = millis();
  }


#ifdef DEBUG
  samplingtime=timenow - timethen;
  Serial.println();
  Serial.print("Collected ");
  Serial.print(MAXsamples);
  Serial.print(" samples in ");
  Serial.print(samplingtime);
  Serial.println("ms");
#endif

  // Get current date & time
  getDateDs1307(&second, &minute, &hour, &dayOfWeek, &dayOfMonth, &month, &year);
  // YYMMDDHHMMSS
  sampledate=(long)year*10000+(long)month*100+dayOfMonth;
  sampletime=(long)hour*10000+minute*100+second;

  // Read a DS18S20 on the clock board
  GetTempC();
    
/*
  lcd.setCursor(0,0);
  lcd.print("sampling data   ");
  lcd.setCursor(0,1);
  lcd.print(ADC_Vref);
  lcd.print(":");
  lcd.print(ADC_step_mV);
  lcd.print("                ");
//  delay(1000);
//  delay(10000);
*/

  timethen =  millis();
  for (channel=0;channel<maxChannels;channel++){
    CheckKeys();
    switch (channel) {
    case 0:
      ctimethen =  millis(); 
      //Figure out the RATIO by
      // (ch_valuesummary[0])/(current line voltage measured with DMM)/1000
      // or;  CurrentRATION*(LCD Voltage)/(DMM Voltage)
      readVolt(channel,12.252); // Channel,RATIO+calibration (mainvolt/measurevolt, 120VAC->9VAC &  470k/47k=120/9/(470/47)=133.33+CAL+rms)
      ctimenow =  millis();
      //      buffvalues[buffhead].valuesummary[channel]=ch_sumI[channel]; // really main voltage in this case
      buffvalues[buffhead].valuesummary[channel]=ch_valuesummary[channel]; //
      ch_samplingtime[channel]=ctimenow-ctimethen;
      lineVoltage=int(ch_sumI[0]/100); // What is a better way to strip it down to one decimal ?
      lineVoltage=lineVoltage/10;
      break; 
    case 1:
    case 2:
      // Desired voltage/max amps*turns=burdenR ohm
      // (2.5p2p/sqrt(2))/120A*3000=44.19ohm
      // Desired voltage/ohm*turns=Max amps
      // 2.5/sqrt(2))/47.6*3000=111
      readrmsI(channel,double(1.76777/111)); // Channel,CT_MAXVOLT/CT_MAXAMPS
//      buffvalues[buffhead].valuesummary[channel]=ch_sumI[channel];
      buffvalues[buffhead].valuesummary[channel]=ch_valuesummary[channel];
      ch_samplingtime[channel]=ctimenow-ctimethen;
      break;
    default:
      readrmsI(channel,double(1.0/30)); // Channel,CT_MAXVOLT/CT_MAXAMPS
      buffvalues[buffhead].valuesummary[channel]=ch_valuesummary[channel];
      ch_samplingtime[channel]=ctimenow-ctimethen;
    }
  }
  buffvalues[buffhead].sampledate=sampledate;
  buffvalues[buffhead].sampletime=sampletime;
  buffvalues[buffhead].reported=0;
  buffvalues[buffhead].tempC=tempC*10; // temp * 10 to stay integer
  buffvalues[buffhead].samples=MAXsamples;

  totsamples++;
  if ( totsamples > 30 ) { //let the filter settle before saving anything
    printValue(buffhead);
    buffvalues[buffhead].reported++;
    buffhead++;
  }
  if (buffhead == buffersize) {
    dumpBuff(true,false);
    buffhead=0;  
  }

  timenow = millis();
  samplingtime=timenow - timethen;

  Serial.println();

  Serial.print("Total sampling time:");
  Serial.print(samplingtime);
  Serial.print(" milliseconds, Samples:");
  Serial.print(MAXsamples);
  Serial.print(", Temp: ");
  Serial.print(tempC);
  Serial.print("C, min/max/midpoint:");
  Serial.print(ch_LOWval[0]);
  Serial.print("/");
  Serial.print(ch_HIGHval[0]);
  Serial.print("/");
  Serial.print((ch_HIGHval[0]-ch_LOWval[0])/2+ch_LOWval[0]);
  Serial.print(" main:");
  Serial.print(lineVoltage);
  Serial.print("V, Free ram: ");
  Serial.print(freeRam());
  Serial.print(", stack unused ");
  Serial.print(stackUnused());
  Serial.print(", totsamples: ");
  Serial.print(totsamples);
  Serial.println();

  Serial.print("#channel");
  Serial.print(",");
  Serial.print("date");
  Serial.print(",");
  Serial.print("min");
  Serial.print(",");
  Serial.print("max");
  Serial.print(",");
  Serial.print("midpoint");
  Serial.print(",");
  Serial.print("stime");
  Serial.print(",");
  Serial.print("valsum");
  Serial.print(",");
  Serial.print("sumV");
  Serial.print(",");
  Serial.print("sumI");
  Serial.println();

//Data collected, lets show it
  lcd.clear();
  lcd.setCursor(0,0);
  if (dispmode==1){
    // YYYYMMDD HHMMSS
    // <watt.1>/<watt.2>
    lcd.print("20");
    lcd.print(year, DEC);
    if (month<10){lcd.print("0");}
    lcd.print(month, DEC);
    if (dayOfMonth<10) lcd.print("0");
    lcd.print(dayOfMonth, DEC);
    lcd.print(" ");
    if  (hour<10) lcd.print("0"); 
    lcd.print(hour, DEC);
    if  (minute<10) lcd.print("0"); 
    lcd.print(minute, DEC);
    if (second<10) lcd.print("0");
    lcd.print(second, DEC);
    lcd.setCursor(0,1); // next line
    lcd.print(lineVoltage,DEC);
    lcd.setCursor(6,1); // need to strip off all decimals
    lcd.print("V ");
    if (WattLast){
      lcd.print(tempC);
      lcd.print("C         ");
      WattLast=false;
    } else {
      //      TotWatt=ch_sumI[1]*lineVoltage+ch_sumI[2]*lineVoltage;
      lcd.print(ch_sumI[1]*lineVoltage+ch_sumI[2]*lineVoltage);
      lcd.print("W         ");
      WattLast=true;
    }
  } else if (dispmode==2){
    // <lowcnt.basech>/<highcnt.basech>/midpoint
    // <lowcnt.basech+1>/<highcnt.basech+1>/midpoint
    lcd.print(ch_LOWval[basech]);
    lcd.print("/");
    lcd.print(ch_HIGHval[basech]);
    lcd.print("/");
    lcd.print((ch_HIGHval[basech]-ch_LOWval[basech])/2+ch_LOWval[basech]);
    lcd.setCursor(0,1); // next line
    lcd.print(ch_LOWval[basech+1]);
    lcd.print("/");
    lcd.print(ch_HIGHval[basech+1]);
    lcd.print("/");
    lcd.print((ch_HIGHval[basech+1]-ch_LOWval[basech+1])/2+ch_LOWval[basech+1]);
    lcd.setCursor(15,1); // 
    lcd.print(basech);
    //    lcd.print(ch_sumI[0]/100);
    //    lcd.print(lineVoltage);
    //    lcd.print("V");
  } else if (dispmode==3){
    // <vcc>/ADC_step_mV
    // <MAXsamples>
    lcd.print("vcc");
    lcd.print(ADC_Vref);
    lcd.print(" smV"); //Step milliVolt
    lcd.print(ADC_step_mV);
    lcd.setCursor(0,1); // next line
    lcd.print(MAXsamples);
    //    lcd.print(samples[0]);
  } else if (dispmode==4){
    // <sumI.1> <Watt.1>
    // <sumI.2> <Watt.2>
    lcd.print(1);
    lcd.print(":");
    lcd.print(ch_sumI[1]);
    lcd.print("A ");
    lcd.print(ch_sumI[1]*lineVoltage);
    lcd.print("W");
    lcd.setCursor(0,1); // next line
    lcd.print(2);
    lcd.print(":");
    lcd.print(ch_sumI[2]);
    lcd.print("A ");
    lcd.print(ch_sumI[2]*lineVoltage);
    lcd.print("W");
  } else if (dispmode==5){
    // <sumI.basech> <Watt.basech>
    // <sumI.basech+1> <Watt.basech+1>
    lcd.print(basech);
    lcd.print(":");
    lcd.print(ch_sumI[basech]);
    lcd.print("A ");
    lcd.print(ch_sumI[basech]*lineVoltage);
    lcd.print("W");
    lcd.setCursor(0,1); // next line
    lcd.print(basech+1);
    lcd.print(":");
    lcd.print(ch_sumI[basech+1]);
    lcd.print("A ");
    lcd.print(ch_sumI[basech+1]*lineVoltage);
    lcd.print("W");
  }

  lcd.setCursor(15,0);
  lcd.print(dispmode);
  
  //################################################################  
  for (channel=0;channel<maxChannels;channel++){
    //    lcd.setCursor(15,1);lcd.print(channel);
    if (channel<10){Serial.print(" ");}
    Serial.print(channel);
    Serial.print(",");  
    Serial.print("20");
    Serial.print(year, DEC);
    Serial.print("-");
    if (month<10){Serial.print("0");}
    Serial.print(month, DEC);
    Serial.print("-");
    if (dayOfMonth<10){Serial.print("0");}
    Serial.print(dayOfMonth, DEC);
    Serial.print(" ");
    if (hour <10){Serial.print("0"); }
    Serial.print(hour, DEC);// convert the byte variable to a decimal number when being displayed
    Serial.print(":");
    if (minute<10){Serial.print("0");}
    Serial.print(minute, DEC);
    Serial.print(":");
    if (second<10){Serial.print("0");}
    Serial.print(second, DEC);
    Serial.print(",");
    //
    //    Serial.print(ADC_step_mV);
    //    Serial.print(",");
    Serial.print(ch_LOWval[channel]);
    Serial.print(",");
    Serial.print(ch_HIGHval[channel]);
    Serial.print(",");
    Serial.print(ch_midpoint[channel]);
    Serial.print(",");
    //
    Serial.print(ch_samplingtime[channel]);
    Serial.print(",");
    Serial.print(ch_valuesummary[channel]);
    Serial.print(",");
    //    Serial.print(sqrt(double(ch_valuesummary[channel])/double(samples[channel])));
    //    Serial.print(",");
    Serial.print(ch_sumV[channel]);
    Serial.print(",");
    Serial.print(ch_sumI[channel]);
    //    Serial.print(",");
    //    Serial.print(buffhead);
    //    Serial.print(",");
    //    Serial.print(freeRam(), DEC);
    //    Serial.print(",");
    //    Serial.println(stackUnused(),DEC);
    Serial.println();
  }
  
   
  CheckKeys();
  CheckSerial();

  waitdelay=100; //ms to wait before probing again
  waitloop=1000/waitdelay; // milliseconds between updates
  for (i=0;i<waitloop;i++){ // Wait for around 5 seconds
    prevkey=lastkey;
    CheckKeys();
    if (prevkey==lastkey) {
      delay(waitdelay);
    } else {
      if (lastkey==5){ // Select
	i=waitloop; // I'm done
      }else{
	i=0; // reset timeout
      }
      lcd.clear();
      //      lcd.setCursor(15,0);
      //      lcd.print(dispmode);
      lcd.setCursor(0,0);
      lcd.print("dispmode: ");
      lcd.print(dispmode);
      lcd.setCursor(0,1);
      if (dispmode==1){
	//         1234567890123456
	lcd.print("date/volt/temp ");
      } else if (dispmode==2){
	//         1234567890123456
	lcd.print("LowMidHigh: ");
	lcd.print(basech);
      } else if (dispmode==3){
	//         1234567890123456
	lcd.print("vcc/step/samples");
      } else if (dispmode==4){
	//         1234567890123456
	lcd.print("main I,W");
      } else if (dispmode==5){
	lcd.print("basech  : ");
	lcd.print(basech);
      }
    } // if prev=last;else
  } // for i 0..50
} // loop()

/*
### Set mode for emacs
### fooLocal Variables: ***
### foomode: shellc ***
### fooEnd: ***
*/
